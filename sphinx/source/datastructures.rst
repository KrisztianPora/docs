.. _datastructures:

Data Structures
===============

Specification and examples of data structures used on the OCCO system.

OCCO uses simple data structures that can be expressed in :term:`YAML` scalars
(:class:`str`, :class:`int`, :data:`None`, etc.), mappings (:class:`dict`),
arrays (:class:`list`), and their recursive constructions.

Some of the scalar types OCCO utilizes are complex Python classes that can be
serialized in YAML. For example, :class:`~occo.util.factory.factory.register`
will register a YAML constructor for the specific
:class:`~occo.util.factory.factory.MultiBackend` class so the YAML parser will
automatically instantiate the correct backend for that class. This makes the
example configuration in :ref:`occo.util.factory <factory_example_config>`
possible.

.. _infradescription:

Infrastructure Description
--------------------------

Dependency graph on :ref:`nodedescription`-s.

The graph contains the following information:

    ``user_id``
        The identifier of the owner of the infrastructure instance.
    ``name``
        The name of the infrastructure.
    ``nodes``
        List of node.

        .. todo:: These descriptions are different from compiled node
            descriptions. We need to find a name for these, and document them
            separately.

    ``edges``
        List of edge definitions. Each of these can be either

            - A pair (2-list) of node references.

            - A mapping containing:

                ``connection``
                    The pair (2-list) of node references.

                ``mappings``
                    List of attribute mappings. Each mapping can be

                        - A pair (2-list) of strings (attribute specifications,
                          dotted strings permitted).

                        - A mapping containing:

                            ``attributes``
                                The pair of attribute specifications.
                            ``synch``
                                Whether to synchronize on the availability of
                                the source attribute.
                            ``**``
                                Anything else that is required by mediating
                                services.
                ``**``
                    Anything else that is required by mediating services.

    ``variables``

        Arbitrary mapping containing infrastructure-wide information. This
        information is static (not parsed anywhere). Nodes will inherit these
        variables, but they may also override them.

.. todo:: The use of ``environment_id``, ``infra_id``, and
    ``infrastructure_id`` is inconsistent throughout the code and the system.
    We need to refactor the code and the design so it is consistently called
    ``infrastructure_id``. We should drop the "environment" terminology
    altogether, as it is Chef-specific.

Examples
~~~~~~~~

Diamond
```````

.. code:: yaml

    user_id: 1
    name: diamond
    nodes: &NODES
        - &A
            name: A
            type: mysql-something
        - &B
            name: B
            type: wordpress-something
            scaling:
                max: 5
        - &C
            name: C
            type: something-something-darkside
            scaling:
                min: 2
                max: 5
        - &D
            name: D
            type: yaay
    dependencies:
        - [ *D, *C ]
        -
            connection: [ *D, *B ]
            mappings:
                - [ 'service.from_attribute', 'to_attribute' ]
                -
                    attributes: [ 'attrX', 'node.attribute.Y' ]
                    synch: true
                    extra: information
            extra_connection_property: 1
        - [ *B, *A ]
        - [ *C, *A ]

OC-Demo
```````

.. todo:: Update this example.

.. code:: yaml

    user_id: 1
    name: original_ocdemo
    nodes: &NODES
        - &portal
            name: gUSE
            type: ocdemo_guse
        - &boinc_client
            name: BOINC_client
            type: ocdemo_boinc_client
            scaling:
                min: 2
    dependencies:
        - [ *boinc_client, *portal ]
    variables:
        # The password, and with it this description alltogether, must be
        # generated by the user/API client.
        server_password: static string

.. _nodedescription:

Node Description
----------------

Abstract description of a node, which identifies a type of node a user may
include in an infrastructure. It is an abstract, backend-independent definition
of a class of nodes and can be stored in a repository.

A node description is self-contained in the sense that a node description
contains all the information needed to *resolve* it (i.e., in relational terms:
it does not need to be "joined" with the containing infrastructure).

This data structure does *not* contain information on how it can be
instantiated. It rather contains *what* needs to be instantiated, and under
what *conditions*. It refers to one or more *implementations* that can be used
to instantiate the node. These implementations are described with :ref:`node
definition <nodedefinition>` data structures.

To instantiate a node, its implementations are gathered first. Then, they are
either filtered by ``backend_id`` (if explicitly specified), or one is selected
by some brokering algorithm (currently: randomly).

The node definition will then be resolved to a :ref:`resolved node definition
<resolvednode>` so it contains all information required by the intended
backend. For details, continue to :ref:`nodedefinition`, and then to
:ref:`resolvednode`.

    ``name``
        Uniquely identifies the node inside the infrastructure.

    ``type``
        The type of the node.

    ``backend_id``
        Optional. The dedicated backend for this node. If unspecified, the
        :ref:`Infrastructure Processor <infraprocessor>` will choose among
        implementations.

    ``environment_id``
        Back reference to the containing infrastructure instance.

    ``user_id``
        User identifier of the infrastructure instance. This is an
        optimization.  The :term:`IP` could resolve this by querying the static
        description of the containing infrastructure, but it is much more
        efficient to simply copy the ``user_id`` to each node's description.

    ``attributes``
        Nested mappings specifying node attributes.

    ``mappings``
        Mapping specifying node attribute mapping, inbound and outbound. The
        keys of the mapping are the names of the nodes this node is connected
        with. The values of the mapping are lists containing mapping
        specifications:

            ``inbound``
                List of inbound mappings; that is, mappings this node depends
                on.

            ``outbound``
                List of outbound mappings; that is, mappings through which
                node provides information. The InfrProcessor may synchronize
                on these mappings.

            Each mapping contains a pair of ``attributes`` to be connected, the
            specification whether the IP must synchronize upon this mapping
            (``synch``), and possibly other information used by specialized
            intermediate services in the future. See
            :func:`~occo.compiler.compiler.create_mapping`.

    ``variables``
        Arbitrary mapping containing static node-level information:

        #. Inherited from the infrastructure.
        #. Overridden/specified in the node's description in the
           infrastructure description.

        The final list of variables is assembled by the Compiler

Infrastructure Static State
---------------------------

Describes the desired/ideal state of the infrastructure. Essentially a
topological ordering of the :ref:`infradescription`.

.. todo:: The specification can be foun in the code:
    :class:`occo.compiler.compiler.StaticDescription`

.. _nodedefinition:

Node Definition
---------------

Describes an *implementation* of a :ref:`node <nodedescription>`, a template
that is required to instantiate a node. The template pertains to a specific
:ref:`Cloud Handler <cloudhandler>` (through ``backend_id``), and a specific
:ref:`Service Composer <servicecomposer>` (to be implemented).

A node definition does not contain all information needed to instantiate the
data. It is just a backend-\ *dependent* description that can be stored in a
repository (cf. with :ref:`nodedescription`, which is backend-\ *independent*).

To be used to instantiate a concrete node, this template needs to be resolved;
that is, filled in with actual information. This results in a
:ref:`resolved node definition <resolvednode>` (see there for details).

    ``implementation_type``
        The :mod:`Resolver <occo.infraprocessor.node_resolution>` module uses
        this to select the correct resolver. This string should identify the
        cloud handler + service composer pair that can handle this
        implementation. E.g. ``"chef+cloudinit"``.
    ``...``
        Extra information required by the resolver handling this type of
        implementation. E.g. ``"context_template"`` in case of cloud-init
        backends.

Example
~~~~~~~

.. code:: yaml

    implementation_type: chef+cloudinit
    backend_id: dummy1
    service_composer_id: chef1
    image_id: ami-00000724
    instance_type: m1.medium
    run_list: ''

.. _resolvednode:

Resolved Node Definition
------------------------

The :ref:`node definition <nodedefinition>` contains the *template* to
instantiate a node in a specific backend, but it does not contain actual
details: it must be resolved first.

The resolution in initiated by the :ref:`Infrastructure Processor
<infraprocessor>`, and performed by the :mod:`node resolution
<occo.infraprocessor.node_resolution>` module. The correct resolution algorithm
determines the content of the resolved node definition, which depends on the
backend type of the :ref:`Cloud Handler <cloudhandler>` *and* the type of the
:ref:`Service Composer <servicecomposer>`.

A resolved node definition is not intended to be stored in any permanent
storage as it is product of the :ref:`node definition <nodedefinition>` and
up-to-date information from the :ref:`Information Broker <infobroker>`.

The content of the resolved node definition depends completely on the resolving
algorithm.

Chef+CloudInit Resolver
~~~~~~~~~~~~~~~~~~~~~~~

The Chef-based resolver specifies the following node definition:

    ``node_id``
        Node identifier, generated by the InfraProcessor.

    ``name``
        Node name; the identifier of the node class inside the infrastructure.
        Inherited from the node description.

    ``environment_id``
        The identifier of the infrastructure instance.

    ``auth_data``
        Optional. Node instance-level authentication data for the backend.

    ``context``
        Resolved contextualization information. This will be fed to cloud-init.

    ``attributes``
        Resolved attributes of the node. Nested mappings. This will be fed to
        Chef.

    ``synch_attrs``
        Mapping of nodes names to lists of attributes. This contains the list
        of upstream nodes and, for each of them, the list of attributes that
        are needed to be synchronized upon. I.e., the InfraProcessor will
        *wait* for these attributes to acquire a value.

.. _instancedata:

Instance Data
-------------

Specification of a running node instance. A ``(backend_id, instance_id)`` pair
is required and is sufficient to manipulate a running node instance.

    ``node_id``
        Internal identifier of the node instance.
    ``backend_id``
        Identifies the backend that has actually handled the creation of this
        node.
    ``instance_id``
        Identifier of the node instance in the backend's domain (e.g. boto vm
        id).
    ``user_id``
        User identifier of the infrastructure this node pertains to.
